Hey! 😊 计算函数闭包，关键和标准形式 (1,2,3,3.5) 的方法如下。 我是用 Markdown 格式为你解释: 

1. 📚 **Func Closure:**
   函数闭包是指对于一个函数集合 F, 一个属性集合 X 的闭包 (denoted as X+) 是所有可以通过 F 的函数依赖关系导出 X 的属性集合。

    计算闭包时请遵循以下步骤:
    1. 初始化 X+ = X。
    2. 💫 在 F 中查找所有的函数依赖 A→B, A⊆X+。
    3. 把找到的 B 添加到 X+。
    4. ➰ 重复步骤 2 和 3, 直到 X+ 不再增加。

2. 🔑 **Calculate Key:**
   关键是函数依赖关系集合 F 中唯一确定元组的最小属性子集。

    步骤如下:
    1. 初始化候选关键: CK = 所有属性集合。
    2. 查找 CK 中对应的闭包: CK+。
    3. 核对 CK+ 是否包含所有属性; 如果是，则继续。
    4. 确认 CK 是否是最小属性子集。 如果可以找到一个更小子集，则尝试其他子集。 结果是唯一确定元组的最小属性子集。

3. 💡 **Calculate Normal Forms (1NF, 2NF, 3NF, 3.5NF - BCNF):**
    1. 😄 **1NF (1st Normal Form):** 表满足以下条件时, 就处于 1NF:
       - 所有属性值都是原子的, 即没有可以再分的子值。
    2. 😃 **2NF (2nd Normal Form):** 如果表处于 1NF 且对于表中的每个部分函数依赖 A→B, A 是候选关键的超集，则表处于 2NF。
    3. 😁 **3NF (3rd Normal Form):** 如果表处于 2NF 且对于表中的每个非平凡函数依赖 A→B, A 是候选关键的超集，则表处于 3NF。
    4. 😎 **3.5NF (BCNF - Boyce-Codd Normal Form):** 如果表处于 3NF 且对于表中的每个非平凡函数依赖 A→B, A 是候选关键, 则表处于 BCNF。

希望这些解释对你有所帮助❗ 如果您有其他问题，请随时问。 😊
